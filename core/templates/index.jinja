<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>SysMon Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ── Animations ───────────────────────────────────────────────────── */
        .icon-box {
            transition: transform .15s ease;
        }

        .icon-box:hover {
            transform: scale(1.05);
        }

        /* hover +5 % */
        .icon-box.pop {
            transform: scale(1.15);
        }

        /* click +15 % */
        .tile-img {
            width: 96px;
            height: 96px;
            pointer-events: none;
        }

        /* ── Modal overlay ───────────────────────────────────────────────── */
        #modal-backdrop {
            @apply fixed inset-0 bg-black bg-opacity-50 hidden;
        }

        #modal-wrapper {
            @apply fixed inset-4 lg:inset-10 bg-white rounded-lg shadow-xl overflow-auto hidden;
        }

        /* smooth appear */
        .fade-in {
            animation: fade .15s ease-out forwards;
        }

        @keyframes fade {
            from {
                opacity: 0;
                transform: scale(.96);
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body class="h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-gray-800 text-white px-6 py-3 flex justify-between items-center">
        <h1 class="text-xl font-semibold">SysMon Dashboard</h1>
        <nav class="space-x-4">
            <a href="{{ application_root + url_for('logout') }}" class="hover:underline">Logout</a>
        </nav>
    </header>

    <!-- Main layout -->
    <main class="flex flex-1 overflow-hidden">
        <!-- Sidebar (left) -->
        <aside class="w-64 bg-white border-r px-6 py-4 overflow-y-auto">
            <h2 class="text-lg font-medium mb-4">Menu</h2>
            <ul class="space-y-2">
                <li><button class="filter-btn w-full text-left" data-filter="all">All systems</button></li>
                <li><button class="filter-btn w-full text-left" data-filter="server">Servers</button></li>
                <li><button class="filter-btn w-full text-left" data-filter="desktop">Desktops</button></li>
                <li><button class="filter-btn w-full text-left" data-filter="mini_desktop">Mini‑Desktops</button></li>
                <li><button class="filter-btn w-full text-left" data-filter="laptop">Laptops</button></li>
                <li><button class="filter-btn w-full text-left" data-filter="mobile">Mobiles</button></li>
            </ul>
        </aside>

        <!-- Systems viewport -->
        <section id="system-view" class="flex-1 overflow-auto p-6 bg-gray-50"></section>
    </main>

    <!-- Modal markup (hidden by default) -->
    <div id="modal-backdrop"></div>
    <div id="modal-wrapper" class="p-6 flex flex-col">
        <button id="modal-close" class="ml-auto text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
        <div id="modal-body" class="mt-4"></div>
    </div>

    <!-- Provider / site / system data -->
    <script id="sys-data" type="application/json">{{ providers|tojson }}</script>

    <!-- Client‑side renderer ------------------------------------------------ -->
    <script type="module">
        import { loadIcon } from "{{ url_for('static', filename='js/icon-loader.js') }}";

        /* ── Helper functions (now hoisted) ─────────────────────────────────── */
        function groupBy(arr, fn) {
            return arr.reduce((m, o) => {
                const k = fn(o);
                (m[k] = m[k] || []).push(o);
                return m;
            }, {});
        }

        function chunk(arr, size) {
            const out = [];
            for (let i = 0; i < arr.length; i += size) {
                out.push(arr.slice(i, i + size));
            }
            return out;
        }

        const COMPOSITE_CACHE = new Map();
        const APP_ROOT = "{{ application_root }}";

        /* per‑type stacking meta (same as util.SystemImage) */
        const META = {
            server: { max: 4, dx: 0, dy: -12 },
            desktop: { max: 2, dx: 20, dy: 10 },
            mini_desktop: { max: 4, dx: 0, dy: 0 },
            laptop: { max: 1, dx: 0, dy: 0 },
            mobile: { max: 1, dx: 0, dy: 0 },
        };
        const TILE_PX = 96;     // draw size for each layer
        const SOURCE_SIZE = 120;/* min composite canvas (≈ 96 + margins) */

        /* ---------- build DOM ------------------------------------------------ */
        const providers = JSON.parse(document.getElementById('sys-data').textContent || '[]');
        const view = document.getElementById('system-view');

        providers.forEach(prov => {
            const provWrap = section('mb-10');
            provWrap.append(h('h2', 'text-xl font-semibold mb-4 border-b border-gray-300 pb-1', prov.name));

            prov.sites.forEach(site => {
                const siteWrap = section('mb-8 pl-4 border-l border-gray-200');
                siteWrap.append(h('h3', 'text-base font-medium mb-3 text-gray-700',
                    `${site.name} (${site.type})`));

                const byGroup = groupBy(site.systems, s => s.group || '');
                Object.entries(byGroup).forEach(([grp, list]) => {
                    const grpWrap = h('div', 'mb-6');
                    if (grp) grpWrap.append(h('h4', 'text-sm font-semibold text-gray-600 mb-1', grp));

                    const grid = h('div', 'grid gap-4',
                        null, { style: 'grid-template-columns:repeat(auto-fill,minmax(120px,1fr));' });
                    grpWrap.append(grid); siteWrap.append(grpWrap);

                    const byType = groupBy(list, s => s.type);
                    Object.entries(byType).forEach(([type, arr]) => {
                        const { max } = META[type];
                        for (const stack of chunk(arr, max)) {
                            const tile = h('div', 'text-center');
                            const box = h('a', 'icon-box inline-block',
                                null, {
                                href: `${APP_ROOT}/system_details?id=${stack.at(-1).id}`,
                                'data-type': type
                            });

                            composeIcon(type, stack).then(url => {
                                const img = h('img', 'tile-img', null, { src: url, alt: type });
                                box.append(img);
                            });

                            box.addEventListener('click', ev => {
                                ev.preventDefault();
                                openModal(box.getAttribute('href'));
                            });

                            tile.append(box);
                            tile.append(h('span', 'block mt-1 text-sm truncate',
                                stack.length > 1 ? `${stack.length}× ${type}` : stack[0].name));
                            grid.append(tile);
                        }
                    });
                });

                provWrap.append(siteWrap);
            });
            view.append(provWrap);
        });

        /* ---------- composite builder (Canvas) ------------------------------- */
        async function composeIcon(type, stack) {
            const key = type + '|' + stack.map(s => s.icon_layers?.join('+') || 'on').join(';');
            if (COMPOSITE_CACHE.has(key)) return COMPOSITE_CACHE.get(key);

            const { dx, dy } = META[type];
            const parts = [];
            for (let i = 0; i < stack.length; i++) {
                const sys = stack[i];
                const layers = sys.icon_layers ?? ['on'];
                for (const layer of layers) {
                    parts.push({ img: await loadIcon(type, layer), ox: i * dx, oy: i * dy });
                }
            }

            const minX = Math.min(0, ...parts.map(p => p.ox));
            const minY = Math.min(0, ...parts.map(p => p.oy));
            const maxX = Math.max(...parts.map(p => p.ox + TILE_PX));
            const maxY = Math.max(...parts.map(p => p.oy + TILE_PX));
            const M = 10, cropW = maxX - minX + M * 2, cropH = maxY - minY + M * 2;
            const W = Math.max(cropW, SOURCE_SIZE), H = Math.max(cropH, SOURCE_SIZE);

            const cvs = new OffscreenCanvas(W, H), ctx = cvs.getContext('2d');
            parts.forEach(p => {
                ctx.drawImage(p.img,
                    Math.round((W - cropW) / 2 + M + p.ox - minX),
                    Math.round((H - cropH) / 2 + M + p.oy - minY),
                    TILE_PX, TILE_PX);
            });

            const url = await cvs.convertToBlob({ type: 'image/png' }).then(b => blobToDataURL(b));
            COMPOSITE_CACHE.set(key, url); return url;
        }
        const blobToDataURL = b => new Promise(r => { const fr = new FileReader(); fr.onload = () => r(fr.result); fr.readAsDataURL(b); });

        /* ---------- Modal logic --------------------------------------------- */
        const backdrop = document.getElementById('modal-backdrop');
        const wrapper = document.getElementById('modal-wrapper');
        const body = document.getElementById('modal-body');
        document.getElementById('modal-close').onclick = closeModal;
        backdrop.onclick = closeModal;

        function openModal(url) {
            backdrop.classList.remove('hidden');
            wrapper.classList.remove('hidden'); wrapper.classList.add('fade-in');
            body.innerHTML = '<p class="text-gray-500">Loading…</p>';

            fetch(url, { credentials: 'include' })          //  ← new
                .then(resp => {
                    if (resp.redirected && resp.url.includes('/login')) {
                        throw new Error('login');
                    }
                    return resp.text();
                })
                .then(html => { body.innerHTML = html; })
                .catch(() => { body.innerHTML = '<p class="text-red-600">Failed to load details.</p>'; });
        }
        function closeModal() {
            wrapper.classList.add('hidden'); backdrop.classList.add('hidden'); body.innerHTML = '';
        }

        /* ---------- sidebar filtering --------------------------------------- */
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const filter = btn.dataset.filter;
                document.querySelectorAll('[data-type]').forEach(t => {
                    t.style.display = filter === 'all' || t.dataset.type === filter ? '' : 'none';
                });
            });
        });

        /* ---------- helpers -------------------------------------------------- */
        function h(tag, cls = '', txt = '', attr = {}) {
            const el = document.createElement(tag);
            if (cls) el.className = cls; if (txt) el.textContent = txt;
            Object.entries(attr).forEach(([k, v]) => el.setAttribute(k, v));
            return el;
        }
        function section(cls = '') { return h('section', cls); }

    </script>
</body>

</html>